* Abstract
This library is a bespoke automated and parallelised benchmarking framework to do memory profiling (native and python allocations via [[https://github.com/bloomberg/memray][memray]]), CPU profiling (via [[https://github.com/mstange/samply][samply]]) across [[https://github.com/sympy/sympy][SymPy]] and [[https://github.com/flintlib/python-flint][python-flint]], and benchmarking across =SymPy=, =python-flint=, [[https://www.sagemath.org/][SageMath]], and [[https://www.wolfram.com/mathematica/][Mathematica]]. Including all the different =SymPy= ground types (=python=, =flint=, and =gmpy=), as well as the two different =SymPy= multivariate polynomial implementations (=DMP= and =PolyElement=). It supports early termination of long running functions across all libraries[fn:1].

* Architecture
This is not intended to be used outside of these benchmarks, nor is it intended to be used by anyone, but I'll aim to somewhat document how this works and the troubles I ran time.

** Premise
I wanted an automated, and parallelised way to run both standard benchmarks, and profiling on a dataset and functions. Due to the nature of how this work I needed a rather custom solution. The library needed to support defining common functions and a uniform method of data input. It also needed to support early termination for long running C functions /outside/ of the CPython interpreter (more on this below).

** Data format
*** Polynomials
The CLI takes as input two pickled dictionaries. The first, often named =polys.pickle= contains the polynomials in a grouped format. The keys of the top level dictionary are the "type" or "system name" of the polynomials. It used for separating different polynomial systems (as used in =polynomial_db=), and "classes" of polynomials generated by random generation method (more below). The value there is then a tuple of generators (list of strings), and the list of polynomials as dictionaries. Polynomials are stored as sparse exponent vector, coefficient pairs.

#+begin_src python :results none
  # polys.pickle
  {
      "system name": (
          ["x", "y", ...],  # Generators used for this system
          [
              # First polynomial
              {
                  (0, 1, ...): 2,  # 2*y +
                  (1, 2, ...): 5,  # 5*x*y
                  ...
              },
              # The rest
              ...
          ]
      ),
      ...
  }
#+end_src

Individual functions determine if the list of polynomial should be interpreted as a list, or a system. All polynomials within a system should be within the same ring.

*** Run list
The second pickled dictionary contains the "run list". This is a list of system names to run call each function on. Functions may declare any number of polynomial systems to take as arguments. Functions names correspond to functions defined on the =Library= sub-classes.

#+begin_src python :resutls none
  # run_list.poly
  {
      "add": [
          ("system a", "system b"),
          ...
      ],
      "factor": [
          ("system a",),
          ...
      ]
      ...
  }
#+end_src

** Runtime
From the provided command line arguments, a =RunSpec= sub-classes corresponding to either Python or an "External" library is created. This run spec generates "Runners" that control some sub-process, one for each configuration combination, it knows how to create the particular sub-process for the desired configuration. The specified number of processes are started, these launch a Python interpreter with runs a "Harness". This harness may be run under a different virtual environment, with different environment variables.

The harness sub-processes are responsible for parsing and puppeteering their respective libraries. They receive two line separated file names via =stdin=, for the run configuration, and the output file. Runners are responsible for collecting the results and returning them.
** Built-in harnesses
All existing harness (bar =Mathematica=) make use of fork-ing multi-processes. This is done to allow the termination of long running C process and compatibility with un-pickle-able C types present in =python-flint=.

Long running processes are terminated via =SIGTERM=. This has the unfortunate effect causing error print outs when  using memory profiling. These can be ignored.

* Polynomial generation
This library also has the ability to generate random polynomials with various parameters include
- Number of generators
- Number of terms
- Coefficient ranges
- Exponent ranges

All arguments accept comma separated ranges in the form of =start-stop:step=. Arguments are =eval='d.

The cross product of all arguments are is taken. Be careful.
** Generate polynomials
#+begin_src shell :results verbatim :export both
  python -c "from src.benchmarking.cli import *; gen_polys()" \
      /tmp/ \
      --generators "1" \
      --terms "5" \
      --coefficients "1-100" \
      --exponents "0-10" \
      --seed 1234 2> /dev/null

  python -c "from src.benchmarking.cli import *; gen_polys()" /tmp/polys.pickle --describe
#+end_src

#+RESULTS:
#+begin_example
   generators  terms   exp_range  coeff_range  gens                 poly
0           1      5  (0, 10, 1)  (1, 100, 1)  [x0]  {(7,): 15, (0,):...
1           1      5  (0, 10, 1)  (1, 100, 1)  [x0]  {(0,): 45, (9,):...
2           1      5  (0, 10, 1)  (1, 100, 1)  [x0]  {(2,): 92, (1,):...
3           1      5  (0, 10, 1)  (1, 100, 1)  [x0]  {(1,): 83, (9,):...
4           1      5  (0, 10, 1)  (1, 100, 1)  [x0]  {(4,): 62, (5,):...
5           1      5  (0, 10, 1)  (1, 100, 1)  [x0]  {(0,): 66, (1,):...
6           1      5  (0, 10, 1)  (1, 100, 1)  [x0]  {(0,): 10, (9,):...
7           1      5  (0, 10, 1)  (1, 100, 1)  [x0]  {(5,): 99, (1,):...
8           1      5  (0, 10, 1)  (1, 100, 1)  [x0]  {(4,): 20, (0,):...
9           1      5  (0, 10, 1)  (1, 100, 1)  [x0]  {(9,): 50, (5,):...
#+end_example

#+begin_src shell :results verbatim :export both
  python -c "from src.benchmarking.cli import *; gen_polys()" \
     ./ \
     --generators   "1-5, 6-13:2" \
     --terms        "10" \
     --coefficients "1-1000" \
     --exponents    "0-1000" \
     --number 1 \
     --seed 12 2> /dev/null && \
  python -c "from src.benchmarking.cli import *; gen_polys()" \
     ./ \
     --generators   "1-5, 6-13:2" \
     --terms        "10" \
     --coefficients "2**65-2**66" \
     --exponents    "0-1000" \
     --number 1 \
     --seed 34 \
     --append 2> /dev/null && \
  python -c "from src.benchmarking.cli import *; gen_polys()" \
     ./ \
     --generators   "5" \
     --terms        "4-33:4" \
     --coefficients "1-1000" \
     --exponents    "0-1000" \
     --number 1 \
     --seed 45 \
     --append 2> /dev/null && \
  python -c "from src.benchmarking.cli import *; gen_polys()" \
     ./ \
     --generators   "5" \
     --terms        "4-33:4" \
     --coefficients "2**65-2**66" \
     --exponents    "0-1000" \
     --number 1 \
     --seed 67 \
     --append 2> /dev/null && \
  python -c "from src.benchmarking.cli import *; gen_polys()" ./polys.pickle --describe
#+end_src

#+RESULTS:
#+begin_example
    generators  terms     exp_range          coeff_range                 gens                 poly
0            1     10  (0, 1000, 1)         (1, 1000, 1)                 [x0]  {(485,): 276, (6...
1            2     10  (0, 1000, 1)         (1, 1000, 1)             [x0, x1]  {(1, 677): 640, ...
2            3     10  (0, 1000, 1)         (1, 1000, 1)         [x0, x1, x2]  {(521, 228, 93):...
3            4     10  (0, 1000, 1)         (1, 1000, 1)     [x0, x1, x2, x3]  {(990, 196, 999,...
4            6     10  (0, 1000, 1)         (1, 1000, 1)  [x0, x1, x2, x3,...  {(37, 443, 283, ...
..         ...    ...           ...                  ...                  ...                  ...
27           5     16  (0, 1000, 1)  (368934881474191...  [x0, x1, x2, x3,...  {(956, 486, 317,...
28           5     20  (0, 1000, 1)  (368934881474191...  [x0, x1, x2, x3,...  {(793, 787, 942,...
29           5     24  (0, 1000, 1)  (368934881474191...  [x0, x1, x2, x3,...  {(843, 288, 152,...
30           5     28  (0, 1000, 1)  (368934881474191...  [x0, x1, x2, x3,...  {(434, 762, 414,...
31           5     32  (0, 1000, 1)  (368934881474191...  [x0, x1, x2, x3,...  {(192, 382, 783,...
#+end_example

* Footnotes

[fn:1]While the =stderr= output may not appear graceful when terminating long running memory profiles, enough data is preserved to make conclusions about the programs memory usage /up until/ it was terminated.
